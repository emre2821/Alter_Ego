#!/usr/bin/env python3
"""
Synchronize dependency constraints across pyproject files and requirements.

- Validates that overlapping dependency ranges match between the root and
  the package-local ``pyproject.toml`` files.
- Enforces identical ``rag`` optional dependency groups.
- Regenerates ``src/alter_ego/requirements.txt`` from the canonical
  dependency lists to avoid version drift.
"""
from __future__ import annotations

import re
import sys
from pathlib import Path

import tomllib

ROOT = Path(__file__).resolve().parents[1]
ROOT_PYPROJECT = ROOT / "pyproject.toml"
PKG_PYPROJECT = ROOT / "src" / "alter_ego" / "pyproject.toml"
REQ_PATH = ROOT / "src" / "alter_ego" / "requirements.txt"

DEP_NAME = re.compile(r"^[A-Za-z0-9_.-]+")


def _load_toml(path: Path) -> dict:
    try:
        return tomllib.loads(path.read_text())
    except Exception as exc:  # pragma: no cover - defensive guardrail
        raise RuntimeError(f"Failed to parse {path}: {exc}")


def _dep_map(deps: list[str]) -> dict[str, str]:
    mapping: dict[str, str] = {}
    for dep in deps:
        match = DEP_NAME.match(dep)
        if not match:
            raise ValueError(f"Cannot parse dependency name from: {dep}")
        mapping[match.group(0).lower()] = dep
    return mapping


def _fmt_mismatches(label: str, mismatches: list[tuple[str, str, str]]) -> str:
    details = "\n".join(f"- {name}: {left} != {right}" for name, left, right in mismatches)
    return f"{label}\n{details}"


def _compare_dependency_ranges(root_map: dict[str, str], pkg_map: dict[str, str]) -> None:
    overlap = sorted(root_map.keys() & pkg_map.keys())
    mismatches = [
        (name, root_map[name], pkg_map[name]) for name in overlap if root_map[name] != pkg_map[name]
    ]
    if mismatches:
        message = _fmt_mismatches("Dependency ranges differ between pyproject files:", mismatches)
        raise SystemExit(message)


def _enforce_rag_alignment(root_data: dict, pkg_data: dict) -> list[str]:
    root_rag = root_data["project"]["optional-dependencies"].get("rag", [])
    pkg_rag = pkg_data["project"]["optional-dependencies"].get("rag", [])
    if sorted(root_rag) != sorted(pkg_rag):
        mismatches = _fmt_mismatches(
            "RAG extras differ:",
            [("rag", str(root_rag), str(pkg_rag))],
        )
        raise SystemExit(mismatches)
    return root_rag


def _generate_requirements(root_map: dict[str, str], pkg_map: dict[str, str]) -> list[str]:
    unique_pkg_deps = [spec for name, spec in sorted(pkg_map.items()) if name not in root_map]
    lines = [
        "# Auto-generated by scripts/sync_dependencies.py; do not edit by hand.",
        "# Install Alter/Ego with the RAG extras to keep version constraints synced with pyproject.toml.",
        "..[rag]",
        "",
        *unique_pkg_deps,
        "",
    ]
    return lines


def main() -> int:
    root_data = _load_toml(ROOT_PYPROJECT)
    pkg_data = _load_toml(PKG_PYPROJECT)

    root_deps = _dep_map(root_data["project"]["dependencies"])
    pkg_deps = _dep_map(pkg_data["project"]["dependencies"])

    _compare_dependency_ranges(root_deps, pkg_deps)
    _enforce_rag_alignment(root_data, pkg_data)

    requirements = "\n".join(_generate_requirements(root_deps, pkg_deps))
    REQ_PATH.write_text(requirements)

    print(f"Refreshed {REQ_PATH.relative_to(ROOT)}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
